/* 1.0.0 */
/*****************************************************************************************************************************************************************\
* Module Name       : Amicable
* Description       : Euler Project 21 Source Code
* Original Author   : Jake Nabozny
* Date Created      : 10/31/2012
\*****************************************************************************************************************************************************************/


/*******************************************************************************\
* Include Files
\*******************************************************************************/
#include "amicable_private.h"


/*******************************************************************************\
* Macro Definitions
\*******************************************************************************/
#define AMICABLE_LIMIT    (10000)
// Answer: 31626


/*******************************************************************************\
* Static Variables
\*******************************************************************************/
static U2 u2_s_amicable_array[AMICABLE_LIMIT];


/*******************************************************************************\
* Static Functions
\*******************************************************************************/
static U4 u4_s_Amicable_FindPairsSum(void);
static U4 u4_s_Amicable_CalcDn(U4);


/*******************************************************************************\
* Function Definitions
\*******************************************************************************/


/*****************************************************************************************************************************************************************\
* Function name     : vd_g_Amicable_Main
* Called by         : main
* Argument(s)       : void
* Return            : void
* Description       : Entry Point for Euler Project 21 Amicable
\*****************************************************************************************************************************************************************/
void vd_g_Amicable_Main(void)
{
    U4 u4_t_ans;

    cout << "Find the sum of all amicable numbers below " << AMICABLE_LIMIT << "..\n\n";

    u4_t_ans = u4_s_Amicable_FindPairsSum();

    cout << "Answer:\t" << u4_t_ans << "\n\n";
}


/*****************************************************************************************************************************************************************\
* Function name     : u4_s_Amicable_FindPairsSum
* Called by         : vd_g_Amicable_Main
* Argument(s)       : void
* Return            : U4
* Description       : FindPairs
\*****************************************************************************************************************************************************************/
static U4 u4_s_Amicable_FindPairsSum(void)
{
    U4 u4_t_rtn_sum;
    U4 u4_t_a;
    U4 u4_t_b;
    U4 u4_t_tmp;

    u4_t_rtn_sum = (U4)0;

    for(u4_t_a = (U4)1; u4_t_a < (U4)AMICABLE_LIMIT; u4_t_a++)
    {
        u4_t_b   = u4_s_Amicable_CalcDn(u4_t_a);
        u4_t_tmp = u4_s_Amicable_CalcDn(u4_t_b);

        if(
            (u4_t_tmp == u4_t_a) &&
            (u4_t_a   != u4_t_b)
          )
        {
            u4_t_rtn_sum += u4_t_a;
        }
    }

    return(u4_t_rtn_sum);
}


/*****************************************************************************************************************************************************************\
* Function name     : vd_s_Amicable_CalcDn
* Called by         : u4_s_Amicable_FindPairsSum
* Argument(s)       : void
* Return            : void
* Description       : Find d(n) for all values under AMICABLE_LIMIT, where d(n) = Sum of all even divisors of n
\*****************************************************************************************************************************************************************/
static U4 u4_s_Amicable_CalcDn(U4 u4_a_val)
{
    U4 u4_t_rtn;
    U4 u4_t_idx;

    u4_t_rtn = (U4)0;

    for(u4_t_idx = (U4)1; u4_t_idx < u4_a_val; u4_t_idx++)
    {
        if((u4_a_val % u4_t_idx) == (U4)0)
        {
            u4_t_rtn += u4_t_idx;
        }
    }

    return(u4_t_rtn);
}
